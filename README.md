# Rush Hour Logic Game Solver

### Background
I got the idea to make this program when my step-son recieved the Rush Hour game for his birthday. I just got some practice in graph traversal and search algorithms from a recent class, so I wanted to see if I could find a reasonable solution.
The code was written entirely by me. The concepts were learned in the CS50-AI class.
Chat-GPT was used very minimally to help brainstorm and troubleshoot, especially for finding a way to optimize the final script. No code was generated by AI.

### Optimizations
The most computationally expensive step was the function that checks previously explored/ "seen" states, or board positions. This is necessary to make sure you don't go into an infinite loop (moving a car back and forth forever, for example).
Two optimizations I made were:
1 - changing the explored object from a list of arrays to a set of byte strings. This changed search time from O(N) to O(1).
2 - changing the checker function from an "all" boolean comparison `np.all(array_a, array_b)` to a byte string search in the set `array.tobytes() in memo`.
These changes made the script run about 99% faster. Before the changes, the most difficult problem took ~2 mins to solve, whereas afterwards, it took about 1.7 seconds. 

### Run
To run the game, clone the repo to your machine and simply execute solve.py
The only dependency is numpy. 
To select which board to solve, you can adjust the problem variable at the top of solve.py. The current options that I've written manually are b0, b1, and b40. Feel free to add more and set them equal to the problem variable. 
These are list of lists objects, not numpy arrays, although it should work with either. 

### Solution
The solution returns a list of tuples (representing moves) to be taken in chronological order. Each tuple  `(a,b)` represents a move `b` by a car `a`. For example, (4, -1) means move car #4 one step back. I use index notation for my steps, meaning a positive step is a step in the direcetion of increasing indices, and vice-versa. For horizontal cars, a positive step moves to the right. For vertical cars, a positive step is down. This was a convenient implementation to use with indices, but perhaps not best for readability. 
![rush hour game picture](https://www.safariltd.com/cdn/shop/products/rush-hour-traffic-jam-logic-game-942258.webp?v=1698371033&width=1200)
